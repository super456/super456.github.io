import{_ as l,D as p,c as h,o as k,a6 as n,I as a,j as s,a as t,t as e}from"./chunks/framework.BOyJDVBP.js";const S=JSON.parse('{"title":"Vue3 学习笔记（一）","description":"","frontmatter":{"title":"Vue3 学习笔记（一）","date":"2023-12-23T20:00:00.000Z","tag":["Vue"],"categories":["前端进击"]},"headers":[],"relativePath":"posts/growth-record/frame/vue/vue3-study-01.md","filePath":"posts/growth-record/frame/vue/vue3-study-01.md","lastUpdated":1714532250000}'),E={name:"posts/growth-record/frame/vue/vue3-study-01.md"},r=n("",4),d=n("",30),g=s("li",null,"与 reactive 对象不同的是，当 ref 作为响应式数组或原生集合类型(如 Map) 中的元素被访问时，它不会被解包",-1),y=n("",84),F=s("p",null,"详细解释版：",-1),c=n("",47),o=n("",167),A=n("",15),u=n("",7),D=n("",14),C=s("p",null,[t("注意⚠️：虽然这里的 "),s("code",null,"<Footer>"),t(" 组件可能根本不关心这些 props，但为了使 "),s("code",null,"<DeepChild>"),t(" 能访问到它们，仍然需要定义并向下传递。"),s("strong",null,"如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”，显然是希望尽量避免的情况")],-1),v=s("p",null,[s("code",null,"provide"),t(" 和 "),s("code",null,"inject"),t(" 可以帮助我们解决这一问题。 "),s("strong",null,"一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖：")],-1),m=n("",41);function B(b,f,q,x,_,P){const i=p("CustomImage");return k(),h("div",{"data-pagefind-body":!0},[r,a(i,{src:"/growth-record/frame/vue/vue3study01.webp"}),d,s("ul",null,[g,s("li",null,[t("在模板渲染上下文中，只有顶级的 ref 属性才会被解包，但是，另一个需要注意的点是，如果 ref 是文本插值的最终计算值 (即 "),s("code",null,e(),1),t(" 标签)，那么它将被解包")])]),y,a(i,{src:"/growth-record/frame/vue/vue3study02.webp"}),F,a(i,{src:"/growth-record/frame/vue/vue3study18.png"}),c,a(i,{src:"/growth-record/frame/vue/vue3study03.webp"}),o,a(i,{src:"/growth-record/frame/vue/vue3study04.webp"}),A,a(i,{src:"/growth-record/frame/vue/vue3study05.webp"}),u,a(i,{src:"/growth-record/frame/vue/vue3study06.webp"}),D,a(i,{src:"/growth-record/frame/vue/vue3study07.webp"}),C,v,a(i,{src:"/growth-record/frame/vue/vue3study08.webp"}),m])}const T=l(E,[["render",B]]);export{S as __pageData,T as default};
