import{j as s,b as i,c as a,aa as n}from"./chunks/framework.BdPFiiJb.js";const u=JSON.parse('{"title":"521. 最长特殊序列 Ⅰ","description":"","frontmatter":{"title":"521. 最长特殊序列 Ⅰ","date":"2023-01-22T20:03:06.000Z","tag":["算法"],"categories":["前端进击"]},"headers":[],"relativePath":"posts/growth-record/computer/algorithm/2023/521.md","filePath":"posts/growth-record/computer/algorithm/2023/521.md","lastUpdated":1713799990000}'),t={name:"posts/growth-record/computer/algorithm/2023/521.md"},e=n(`<h1 id="_521-最长特殊序列-i" tabindex="-1">521. 最长特殊序列 Ⅰ <a class="header-anchor" href="#_521-最长特殊序列-i" aria-label="Permalink to &quot;521. 最长特殊序列 Ⅰ&quot;">​</a></h1><h2 id="解题过程" tabindex="-1">解题过程 <a class="header-anchor" href="#解题过程" aria-label="Permalink to &quot;解题过程&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-i/" target="_blank" rel="noreferrer">题目链接</a> 给你两个字符串 a 和 b，请返回 这两个字符串中 最长的特殊序列  的长度。如果不存在，则返回 -1 。 「最长特殊序列」 定义如下：该序列为 某字符串独有的最长子序列（即不能是其他字符串的子序列） 。 字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。 例如，&quot;abc&quot; 是 &quot;aebdc&quot; 的子序列，因为删除 &quot;aebdc&quot; 中斜体加粗的字符可以得到 &quot;abc&quot; 。 &quot;aebdc&quot; 的子序列还包括 &quot;aebdc&quot; 、 &quot;aeb&quot; 和 &quot;&quot; (空字符串)</p></div><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@link</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> https://leetcode.cn/problems/longest-uncommon-subsequence-i/</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@title</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 521. 最长特殊序列 Ⅰ</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@description</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 给你两个字符串 a 和 b，请返回 这两个字符串中 最长的特殊序列  的长度。如果不存在，则返回 -1 。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">「最长特殊序列」 定义如下：该序列为 某字符串独有的最长子序列（即不能是其他字符串的子序列） 。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">例如，&quot;abc&quot; 是 &quot;aebdc&quot; 的子序列，因为删除 &quot;aebdc&quot; 中斜体加粗的字符可以得到 &quot;abc&quot; 。 &quot;aebdc&quot; 的子序列还包括 &quot;aebdc&quot; 、 &quot;aeb&quot; 和 &quot;&quot; (空字符串)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {string}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {string}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 解法一</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 思路：如果两个字符串相等，则没有最长的特殊序列，否则就是字符串本身就是最长序列了</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findLUSlength</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findLUSlength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;aba&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;cdc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result)</span></span></code></pre></div><h2 id="解题感受" tabindex="-1">解题感受 <a class="header-anchor" href="#解题感受" aria-label="Permalink to &quot;解题感受&quot;">​</a></h2><p>这一题一看题目意思感觉好像比较复杂，但其实就是很简单的一道题，就是计算两个字符串谁的长度最大即可，前提条件是不能相等，相等则没有最长特殊子序列。有时候题目描述很多，还要自己提炼关键词计总结简单的题目意思，不要被干扰了</p><h2 id="优质题解" tabindex="-1">优质题解 <a class="header-anchor" href="#优质题解" aria-label="Permalink to &quot;优质题解&quot;">​</a></h2><ul><li><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-i/solution/zui-chang-te-shu-xu-lie-i-by-leetcode-so-v9sr/" target="_blank" rel="noreferrer">https://leetcode.cn/problems/longest-uncommon-subsequence-i/solution/zui-chang-te-shu-xu-lie-i-by-leetcode-so-v9sr/</a></li><li><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-i/solution/qi-xi-suan-fa-521-zui-chang-te-shu-xu-lie-i-by-gua/" target="_blank" rel="noreferrer">https://leetcode.cn/problems/longest-uncommon-subsequence-i/solution/qi-xi-suan-fa-521-zui-chang-te-shu-xu-lie-i-by-gua/</a></li></ul>`,8),l=[e];function h(p,k,r,o,d,c){return i(),a("div",null,l)}const E=s(t,[["render",h]]);export{u as __pageData,E as default};
